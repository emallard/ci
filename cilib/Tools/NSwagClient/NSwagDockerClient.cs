//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.15.4.0 (NJsonSchema v9.10.29.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

namespace MyNamespace
{
    #pragma warning disable // Disable all warnings

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "11.15.4.0 (NJsonSchema v9.10.29.0 (Newtonsoft.Json v9.0.0.0))")]
    public partial class NSwagDockerClient 
    {
        private string _baseUrl = "";
        private System.Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;
        System.Net.Http.HttpClient _injectedClient;

        public NSwagDockerClient(string baseUrl, System.Net.Http.HttpClient _injectedClient)
        {
            BaseUrl = baseUrl; 
            this._injectedClient = _injectedClient;
            _settings = new System.Lazy<Newtonsoft.Json.JsonSerializerSettings>(() => 
            {
                var settings = new Newtonsoft.Json.JsonSerializerSettings();
                UpdateJsonSerializerSettings(settings);
                return settings;
            });
        }
    
        public string BaseUrl 
        {
            get { return _baseUrl; }
            set { _baseUrl = value; }
        }
    
        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }
    
        partial void UpdateJsonSerializerSettings(Newtonsoft.Json.JsonSerializerSettings settings);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);
    
        /// <summary>Build an image</summary>
        /// <param name="inputStream">A tar archive compressed with one of the following algorithms: identity (no compression), gzip, bzip2, xz.</param>
        /// <param name="dockerfile">Path within the build context to the `Dockerfile`. This is ignored if `remote` is specified and points to an external `Dockerfile`.</param>
        /// <param name="t">A name and optional tag to apply to the image in the `name:tag` format. If you omit the tag the default `latest` value is assumed. You can provide several `t` parameters.</param>
        /// <param name="extrahosts">Extra hosts to add to /etc/hosts</param>
        /// <param name="remote">A Git repository URI or HTTP/HTTPS context URI. If the URI points to a single text file, the file’s contents are placed into a file called `Dockerfile` and the image is built from that file. If the URI points to a tarball, the file is downloaded by the daemon and the contents therein used as the context for the build. If the URI points to a tarball and the `dockerfile` parameter is also specified, there must be a file with the corresponding path inside the tarball.</param>
        /// <param name="q">Suppress verbose build output.</param>
        /// <param name="nocache">Do not use the cache when building the image.</param>
        /// <param name="cachefrom">JSON array of images used for build cache resolution.</param>
        /// <param name="pull">Attempt to pull the image even if an older image exists locally.</param>
        /// <param name="rm">Remove intermediate containers after a successful build.</param>
        /// <param name="forcerm">Always remove intermediate containers, even upon failure.</param>
        /// <param name="memory">Set memory limit for build.</param>
        /// <param name="memswap">Total memory (memory + swap). Set as `-1` to disable swap.</param>
        /// <param name="cpushares">CPU shares (relative weight).</param>
        /// <param name="cpusetcpus">CPUs in which to allow execution (e.g., `0-3`, `0,1`).</param>
        /// <param name="cpuperiod">The length of a CPU period in microseconds.</param>
        /// <param name="cpuquota">Microseconds of CPU time that the container can get in a CPU period.</param>
        /// <param name="buildargs">JSON map of string pairs for build-time variables. Users pass these values at build-time. Docker uses the buildargs as the environment context for commands run via the `Dockerfile` RUN instruction, or for variable expansion in other `Dockerfile` instructions. This is not meant for passing secret values. [Read more about the buildargs instruction.](https://docs.docker.com/engine/reference/builder/#arg)</param>
        /// <param name="shmsize">Size of `/dev/shm` in bytes. The size must be greater than 0. If omitted the system uses 64MB.</param>
        /// <param name="squash">Squash the resulting images layers into a single layer. *(Experimental release only.)*</param>
        /// <param name="labels">Arbitrary key/value labels to set on the image, as a JSON map of string pairs.</param>
        /// <param name="networkmode">Sets the networking mode for the run commands during build. Supported standard values are: `bridge`, `host`, `none`, and `container:<name|id>`. Any other value is taken as a custom network's name to which this container should connect to.</param>
        /// <param name="x_Registry_Config">This is a base64-encoded JSON object with auth configurations for multiple registries that a build may refer to.
        /// 
        /// The key is a registry URL, and the value is an auth configuration object, [as described in the authentication section](#section/Authentication). For example:
        /// 
        /// ```
        /// {
        ///   "docker.example.com": {
        ///     "username": "janedoe",
        ///     "password": "hunter2"
        ///   },
        ///   "https://index.docker.io/v1/": {
        ///     "username": "mobydock",
        ///     "password": "conta1n3rize14"
        ///   }
        /// }
        /// ```
        /// 
        /// Only the registry domain name (and port if not the default 443) are required. However, for legacy reasons, the Docker Hub registry must be specified with both a `https://` prefix and a `/v1/` suffix even though Docker will prefer to use the v2 registry API.</param>
        /// <param name="platform">Platform in the format os[/arch[/variant]]</param>
        /// <returns>no error</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task ImageBuildAsync(System.IO.Stream inputStream, string dockerfile, string t, string extrahosts, string remote, bool? q, bool? nocache, string cachefrom, string pull, bool? rm, bool? forcerm, int? memory, int? memswap, int? cpushares, string cpusetcpus, int? cpuperiod, int? cpuquota, int? buildargs, int? shmsize, bool? squash, string labels, string networkmode, ContentType? content_type, string x_Registry_Config, string platform)
        {
            return ImageBuildAsync(inputStream, dockerfile, t, extrahosts, remote, q, nocache, cachefrom, pull, rm, forcerm, memory, memswap, cpushares, cpusetcpus, cpuperiod, cpuquota, buildargs, shmsize, squash, labels, networkmode, content_type, x_Registry_Config, platform, System.Threading.CancellationToken.None);
        }
    
        /// <summary>Build an image</summary>
        /// <param name="inputStream">A tar archive compressed with one of the following algorithms: identity (no compression), gzip, bzip2, xz.</param>
        /// <param name="dockerfile">Path within the build context to the `Dockerfile`. This is ignored if `remote` is specified and points to an external `Dockerfile`.</param>
        /// <param name="t">A name and optional tag to apply to the image in the `name:tag` format. If you omit the tag the default `latest` value is assumed. You can provide several `t` parameters.</param>
        /// <param name="extrahosts">Extra hosts to add to /etc/hosts</param>
        /// <param name="remote">A Git repository URI or HTTP/HTTPS context URI. If the URI points to a single text file, the file’s contents are placed into a file called `Dockerfile` and the image is built from that file. If the URI points to a tarball, the file is downloaded by the daemon and the contents therein used as the context for the build. If the URI points to a tarball and the `dockerfile` parameter is also specified, there must be a file with the corresponding path inside the tarball.</param>
        /// <param name="q">Suppress verbose build output.</param>
        /// <param name="nocache">Do not use the cache when building the image.</param>
        /// <param name="cachefrom">JSON array of images used for build cache resolution.</param>
        /// <param name="pull">Attempt to pull the image even if an older image exists locally.</param>
        /// <param name="rm">Remove intermediate containers after a successful build.</param>
        /// <param name="forcerm">Always remove intermediate containers, even upon failure.</param>
        /// <param name="memory">Set memory limit for build.</param>
        /// <param name="memswap">Total memory (memory + swap). Set as `-1` to disable swap.</param>
        /// <param name="cpushares">CPU shares (relative weight).</param>
        /// <param name="cpusetcpus">CPUs in which to allow execution (e.g., `0-3`, `0,1`).</param>
        /// <param name="cpuperiod">The length of a CPU period in microseconds.</param>
        /// <param name="cpuquota">Microseconds of CPU time that the container can get in a CPU period.</param>
        /// <param name="buildargs">JSON map of string pairs for build-time variables. Users pass these values at build-time. Docker uses the buildargs as the environment context for commands run via the `Dockerfile` RUN instruction, or for variable expansion in other `Dockerfile` instructions. This is not meant for passing secret values. [Read more about the buildargs instruction.](https://docs.docker.com/engine/reference/builder/#arg)</param>
        /// <param name="shmsize">Size of `/dev/shm` in bytes. The size must be greater than 0. If omitted the system uses 64MB.</param>
        /// <param name="squash">Squash the resulting images layers into a single layer. *(Experimental release only.)*</param>
        /// <param name="labels">Arbitrary key/value labels to set on the image, as a JSON map of string pairs.</param>
        /// <param name="networkmode">Sets the networking mode for the run commands during build. Supported standard values are: `bridge`, `host`, `none`, and `container:<name|id>`. Any other value is taken as a custom network's name to which this container should connect to.</param>
        /// <param name="x_Registry_Config">This is a base64-encoded JSON object with auth configurations for multiple registries that a build may refer to.
        /// 
        /// The key is a registry URL, and the value is an auth configuration object, [as described in the authentication section](#section/Authentication). For example:
        /// 
        /// ```
        /// {
        ///   "docker.example.com": {
        ///     "username": "janedoe",
        ///     "password": "hunter2"
        ///   },
        ///   "https://index.docker.io/v1/": {
        ///     "username": "mobydock",
        ///     "password": "conta1n3rize14"
        ///   }
        /// }
        /// ```
        /// 
        /// Only the registry domain name (and port if not the default 443) are required. However, for legacy reasons, the Docker Hub registry must be specified with both a `https://` prefix and a `/v1/` suffix even though Docker will prefer to use the v2 registry API.</param>
        /// <param name="platform">Platform in the format os[/arch[/variant]]</param>
        /// <returns>no error</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<string> ImageBuildAsync(System.IO.Stream inputStream, string dockerfile, string t, string extrahosts, string remote, bool? q, bool? nocache, string cachefrom, string pull, bool? rm, bool? forcerm, int? memory, int? memswap, int? cpushares, string cpusetcpus, int? cpuperiod, int? cpuquota, int? buildargs, int? shmsize, bool? squash, string labels, string networkmode, ContentType? content_type, string x_Registry_Config, string platform, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/build?");
            if (dockerfile != null) urlBuilder_.Append("dockerfile=").Append(System.Uri.EscapeDataString(ConvertToString(dockerfile, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (t != null) urlBuilder_.Append("t=").Append(System.Uri.EscapeDataString(ConvertToString(t, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (extrahosts != null) urlBuilder_.Append("extrahosts=").Append(System.Uri.EscapeDataString(ConvertToString(extrahosts, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (remote != null) urlBuilder_.Append("remote=").Append(System.Uri.EscapeDataString(ConvertToString(remote, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (q != null) urlBuilder_.Append("q=").Append(System.Uri.EscapeDataString(ConvertToString(q, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (nocache != null) urlBuilder_.Append("nocache=").Append(System.Uri.EscapeDataString(ConvertToString(nocache, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (cachefrom != null) urlBuilder_.Append("cachefrom=").Append(System.Uri.EscapeDataString(ConvertToString(cachefrom, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (pull != null) urlBuilder_.Append("pull=").Append(System.Uri.EscapeDataString(ConvertToString(pull, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (rm != null) urlBuilder_.Append("rm=").Append(System.Uri.EscapeDataString(ConvertToString(rm, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (forcerm != null) urlBuilder_.Append("forcerm=").Append(System.Uri.EscapeDataString(ConvertToString(forcerm, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (memory != null) urlBuilder_.Append("memory=").Append(System.Uri.EscapeDataString(ConvertToString(memory, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (memswap != null) urlBuilder_.Append("memswap=").Append(System.Uri.EscapeDataString(ConvertToString(memswap, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (cpushares != null) urlBuilder_.Append("cpushares=").Append(System.Uri.EscapeDataString(ConvertToString(cpushares, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (cpusetcpus != null) urlBuilder_.Append("cpusetcpus=").Append(System.Uri.EscapeDataString(ConvertToString(cpusetcpus, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (cpuperiod != null) urlBuilder_.Append("cpuperiod=").Append(System.Uri.EscapeDataString(ConvertToString(cpuperiod, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (cpuquota != null) urlBuilder_.Append("cpuquota=").Append(System.Uri.EscapeDataString(ConvertToString(cpuquota, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (buildargs != null) urlBuilder_.Append("buildargs=").Append(System.Uri.EscapeDataString(ConvertToString(buildargs, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (shmsize != null) urlBuilder_.Append("shmsize=").Append(System.Uri.EscapeDataString(ConvertToString(shmsize, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (squash != null) urlBuilder_.Append("squash=").Append(System.Uri.EscapeDataString(ConvertToString(squash, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (labels != null) urlBuilder_.Append("labels=").Append(System.Uri.EscapeDataString(ConvertToString(labels, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (networkmode != null) urlBuilder_.Append("networkmode=").Append(System.Uri.EscapeDataString(ConvertToString(networkmode, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (platform != null) urlBuilder_.Append("platform=").Append(System.Uri.EscapeDataString(ConvertToString(platform, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            urlBuilder_.Length--;
    
            var client_ = this._injectedClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (content_type != null)
                        request_.Headers.TryAddWithoutValidation("Content-type", ConvertToString(content_type, System.Globalization.CultureInfo.InvariantCulture));
                    if (x_Registry_Config != null)
                        request_.Headers.TryAddWithoutValidation("X-Registry-Config", ConvertToString(x_Registry_Config, System.Globalization.CultureInfo.InvariantCulture));
                    var content_ = new System.Net.Http.StreamContent(inputStream);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/octet-stream");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        foreach (var item_ in response_.Content.Headers)
                            headers_[item_.Key] = item_.Value;
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var responseData_ = await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            return responseData_;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var responseData_ = await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("Bad parameter", status_, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var responseData_ = await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("server error", status_, responseData_, headers_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", status_, responseData_, headers_, null);
                        }
                        
                        throw new SwaggerException("unknown status code", status_, "", headers_, null);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (client_ != null)
                    client_.Dispose();
            }
        }
    
        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value is System.Enum)
            {
                string name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute)) 
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value;
                        }
                    }
                }
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[]) value);
            }
            else if (value.GetType().IsArray)
            {
                var array = System.Linq.Enumerable.OfType<object>((System.Array) value);
                return string.Join(",", System.Linq.Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }
        
            return System.Convert.ToString(value, cultureInfo);
        }
    }
    
    

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.10.29.0 (Newtonsoft.Json v9.0.0.0)")]
    public enum ContentType
    {
        [System.Runtime.Serialization.EnumMember(Value = "application/x-tar")]
        Application_xTar = 0,
    
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "11.15.4.0 (NJsonSchema v9.10.29.0 (Newtonsoft.Json v9.0.0.0))")]
    public partial class SwaggerException : System.Exception
    {
        public string StatusCode { get; private set; }

        public string Response { get; private set; }

        public System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public SwaggerException(string message, string statusCode, string response, System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Exception innerException) 
            : base(message, innerException)
        {
            StatusCode = statusCode;
            Response = response; 
            Headers = headers;
        }

        public override string ToString()
        {
            return string.Format("HTTP Response: \n\n{0}\n\n{1}", Response, base.ToString());
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "11.15.4.0 (NJsonSchema v9.10.29.0 (Newtonsoft.Json v9.0.0.0))")]
    public partial class SwaggerException<TResult> : SwaggerException
    {
        public TResult Result { get; private set; }

        public SwaggerException(string message, string statusCode, string response, System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>> headers, TResult result, System.Exception innerException) 
            : base(message, statusCode, response, headers, innerException)
        {
            Result = result;
        }
    }

}